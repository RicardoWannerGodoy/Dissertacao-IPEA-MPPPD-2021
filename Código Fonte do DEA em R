Código Fonte do DEA em R

#################################
# PROJETO PARA A DISSERTAÇÃO    #
# IPEA  MPPPD - 4 Turma         # 
# ANÁLISE ENVOLTÓRIA DE DADOS   #
# DEA - CCR - BCC               #
#################################

########################################################
# Orientador:    Prof. Dr.  Bernardo Alves Furtado     #
# Coorientador:  Prof. Dr. Alexandre dos Santos Cunha  #
# Orientando:    Ricardo Wanner de Godoy               #
########################################################


#######################
# Versão: 04          #
# DAta:   26/06/2021  #
#######################

#################################################################
# A EFICIÊNCIA DAS POLÍTICAS DE SEGURANÇA PÚBLICA NO COMBATE A	#
# CRIMINALIDADE E A VIOLÊNCIA NA CIDADE DE SALVADOR NA BAHIA.   #
#################################################################

# Instalação dos pacotes:
install.packages("Benchmarking")
install.packages("readxl")
install.packages("writexl")
install.packages("dplyr")

library(Benchmarking)
library(lpSolveAPI)
library(ucminf)
library(quadprog)
library(readxl)
library(writexl)
library(dplyr)

###########
# FóRMULA:#
########################################################################################
# Usaremos a função "dea" desse pacote e seus padrões (default):
# dea(X, Y, RTS="vrs", ORIENTATION="in", XREF=NULL, YREF=NULL, FRONT.IDX=NULL, 
#  SLACK=FALSE, DUAL=FALSE, 
# DIRECT=NULL, param=NULL, TRANSPOSE=FALSE, FAST=FALSE, LP=FALSE, CONTROL=NULL, 
# LPK=NULL)
#########################################################################################

################
# ORIENTAÇÃO:#
##############################################################################################
# Inputs Matriz dos Insumos 
# Outputs Matriz dos Produtos 
# Insumo "in" (1), 
# Produto "out" (2), e 
# gráfico da eficiência "graph"
##############################################################################################

###########
# LEGENDA:#
##############################################################################################
# [00] fdh: Free disposability hull, não assumido convexidade;
# [01] vrs: Retornos variáveis à escala, convexidade e free disposability;
# [02] drs: Retornos decrescentes à escala, convexidade, down-scaling e "free disposability" 
# (disponibilidade fraca);
# [03] crs: Retornos constantes à escala, convexidade e free disposability;
# [04] irs: Retornos crescentes à escala, (up-scaling, mas não down-scaling), convexidade e free disposability;
# [05] irs2: Retornos crescentes à escala (up-scaling, mas não down-scaling), additividade e free disposability;
# [06] add: Aditividade (scaling up e down, mas apenas com inteiros), e free disposability; 
# [07] fdh+: Combinação de "free disposability" e restrito ou retornos constantes à escala local;
# [10] vrs+: Retornos variáveis à escala, mas não há restrições sobre os lambdas individuais no parâmetro;
# [11] XREF: Insumos dos Cenários determinando a tecnologia, default (padrão): Inputs;
# [12] YREF: Produtos dos Cenários determinando a tecnologia, default: Outputs;
# [13] FRONT.IDX: Índices dos Cenários determinando a tecnologia;
# [14] SLACK: Calcular as folgas dos insumos/produtos na etapa 2ª via função slack; e
# [15] RTS: Texto ou número definindo o modelo DEA a ser estimado/retornos a escala.
##############################################################################################

#####################################INÍCIO DO SCRIPT #######################################

#*************************************#
# Carregando os dados no R DO "PSPBA".      #
#*************************************#

setwd("C:/Users/User/Desktop/NETLOGO/RStudio/PSPBA")

#**********************************************************************************
# Esse comando evita o retorno dos números em notação científica.
######################
options(scipen = 999)
######################
#**********************************************************************************

SMBA = read_excel("PSPBA.xlsx")

############################
##VERIFICAÇÃO DA BASE:###
str(SMBA)
View(SMBA)
############################

#########################
# CAMPOS DO NETLOGO:#
##############################################################################################
# Legenda:				

# Input1	= prc_acao_policial			
# Input2	= qtd_politicas_publicas			
# Input3	= prc_aplicacao_pol_publicas			
# Output1	= % Cidadãos			
# Output2	= % Infratores			
# Output3	= % Ressocializados			
##############################################################################################
################
# OBSERVAÇÃO:#
##############################################################################################
# Montando a matriz de Insumos E Produtos. Perceba que deve ser combinado todos os insumos via
# função cbind. Pode-se mudar os nomes de acordo com a sua base de dados e incluir quantos desejar, 
# acrescentando, variável.
##############################################################################################
# Criando as matrizes de Inputs e Outputs:
Inputs = as.matrix(with(SMBA,cbind(Input1,Input2,Input3)))

############################
##VERIFICAÇÃO DA BASE:###
str(Inputs)
View(Inputs)
############################

Outputs = as.matrix(with(SMBA,cbind(Output1,Output2,Output3)))

############################
##VERIFICAÇÃO DA BASE:###
str(Outputs)
View(Outputs)
############################

#**********************************************************************************
# Retornos constantes de escala orientado ao insumo.
eff_Const_Input = dea(Outputs, Inputs, RTS = "crs", ORIENTATION = "in")

# Eficiência constante de Insumo.
eff_crs_Input = eff_Const_Input$eff
#**********************************************************************************
# Retornos constantes de escala orientado ao produto.
eff_Const_Output = dea(Outputs, Inputs, RTS = "crs", ORIENTATION = "out")

# Eficiência constante de Produto.
eff_crs_Output = eff_Const_Output$eff
#**********************************************************************************
# Retornos variáveis de escala orientado ao insumo.
eff_Var_Input = dea(Outputs, Inputs, RTS = "vrs", ORIENTATION = "in")

# Eficiência variáveis de Insumo.
eff_vrs_Input = eff_Var_Input$eff
#**********************************************************************************
# Retornos variáveis de escala orientado ao produto.
eff_Var_Output = dea(Outputs, Inputs, RTS="vrs", ORIENTATION = "out")


# Eficiência variáveis de Produto.
eff_vrs_Output = eff_Var_Output$eff
#**********************************************************************************

# Combinando os resultados em uma única tabela.
tab_eff_CRS_VRS = data.frame(DMU= SMBA$DMU,
                             CRS_Input    = eff_crs_Input, 
                             CRS_Ouput    = eff_crs_Output, 
                             VRS_Input    = eff_vrs_Input, 
                             VRS_Output   = eff_vrs_Output,
                             CRS_1_Input  = 1/eff_crs_Input,
                             CRS_1_Output = 1/eff_crs_Output,
                             VRS_1_Input  = 1/eff_vrs_Input, 
                             VRS_1_Output = 1/eff_vrs_Output)


############################
##VERIFICAÇÃO DA BASE:###
str(tab_eff_CRS_VRS)
View(tab_eff_CRS_VRS)
############################

#**********************************************************************************

################
# OBSERVAÇÃO:#
##############################################################################################
# Os escores de eficiência sobre a pressuposição de retornos constantes com orientação insumo e produto 
# são iguais, o que não ocorre sobre a pressuposição de retornos variáveis; os escores de eficiência com 
# a pressuposição de retornos variáveis são maiores do que os calculados sobre a orientação de retornos 
# variáveis.
##############################################################################################
# O que é Isoquanta?
# Em economia, uma isoquanta é uma curva que representa várias combinações de fatores de produção (terra, 
# capital e trabalho) que resultem na mesma quantidade de produção (output). É a curva que representa para 
# a mesma quantidade produzida nas diferentes condições de capital e trabalho.
##############################################################################################

# Traçando a "isoquanta" da base com dois Insumos com retornos variáveis. 
dea.plot.isoquant(x1 = SMBA$Input2, x2 = SMBA$Input3, 
                  xlab = "qtd_politicas_publicas", ylab = "prc_aplicacao_pol_publicas", 
                  RTS = "vrs", txt = T, main = "Isoquanta dos Insumos Retornos Variáveis",
                  pch=18, cex=2, col=rainbow(7))
                  legend("bottomright",legend = SMBA$DMU, text.col = rainbow(7), 
                         cex = 0.6, box.lty = 0, title = "[LEGENDA]:")              
 #**********************************************************************************
 # Traçando a "isoquanta" da base com dois Produtos com com retornos variáveis.
dea.plot.isoquant(x1 = SMBA$Output1, x2 = SMBA$Output3, 
                  xlab = "% Cidadãos", ylab = "% Ressocializados", 
                  RTS = "vrs", txt = T, main = "Isoquanta dos Produtos Retornos Variáveis",
                  pch=18, cex=2, col=rainbow(7))
                  legend("bottomright",legend = SMBA$DMU, text.col = rainbow(7), 
                  cex = 0.6, box.lty = 0, title = "[LEGENDA]:") 

#**********************************************************************************
# Fronteira de possibilidades de produção sobre a pressuposição de retornos constantes. 
dea.plot.frontier(Outputs, Inputs, 
                  xlab="CRS_Insumos", ylab="CRS_Produtos", 
                  RTS = "crs", txt = T, main="Fronteira de Produção Retornos Constantes",
                  pch=18, cex=2, col=rainbow(7))
                  legend("bottomright",legend = SMBA$DMU, text.col = rainbow(7), 
                  cex = 0.6, box.lty = 0, title = "[LEGENDA]:") 

#**********************************************************************************
# Fronteira de possibilidades de produção sobre a pressuposição de retornos variáveis. 
dea.plot.frontier(Outputs, Inputs, 
                  xlab="VRS_Insumos", ylab="VRS_Produtos", 
                  RTS = "vrs", txt = T, main="Fronteira de Produção Retornos Variáveis",
                  pch=18, cex=2, col=rainbow(7))
                  legend("bottomright",legend = SMBA$DMU, text.col = rainbow(7), 
                  cex = 0.6, box.lty = 0, title = "[LEGENDA]:") 
#**********************************************************************************

################
# ORIENTAÇÃO:#
##############################################################################################
# Retornos Constantes x Retornos Variáveis
# Eficiência de Escala x Retorno de Escala
##############################################################################################
# Utilizando um teste estatístico para avaliar se temos ineficiência de escala com os Insumos.
ks.test(eff_crs_Input, eff_vrs_Input, alternative = "two.sided", exact = NULL)

# Ho: Ausência de ineficiência de escala 
# (o modelo com a pressuposição de retornos constantes não é o mais adequado);
# Hi: Presença de ineficiência de escala 
# (o modelo com a pressuposição de retornos variáveis não é o mais adequado);

#############
# RESPOSTA:#
##############################################################################################
# Two-sample Kolmogorov-Smirnov test
# 
# data:  eff_crs_Input and eff_vrs_Input
# D = 0.25, p-value = 0.9996
# alternative hypothesis: two-sided
##############################################################################################

# Calculando a eficiência de escala dos Insumos.
eff_Esc_Input = eff_crs_Input/eff_vrs_Input
#**********************************************************************************
# Determinando a natureza dos retornos de escala.
# Retornos crescentes da escala orientada aos Insumos.
eff_Retor_Cres_Input = dea(Outputs, Inputs, RTS = "irs", ORIENTATION = "in")

# Eficiência irs de Insumo.
eff_irs_Input = eff_Retor_Cres_Input$eff
#**********************************************************************************

# Retornos decrescentes de escala orientada aos Insumos.
eff_Retor_Decres_Input = dea(Outputs, Inputs, RTS = "drs", ORIENTATION = "in")

# Eficiência drs de Insumo.
eff_drs_Input = eff_Retor_Decres_Input$eff
#**********************************************************************************
# Podemos combinar todas as medidas de eficiência em apenas uma tabela dos Insumos.
tab_eff_Input = data.frame(DMU         = SMBA$DMU,
                           RND_Input   = eff_irs_Input, 
                           RNC_Input   = eff_drs_Input, 
                           CRS_Input   = eff_crs_Input, 
                           VRS_Input   = eff_vrs_Input, 
                           Eficiência  = eff_Esc_Input)
#**********************************************************************************
# Concatenando mais de uma função "SE" do Excel, por exemplo:
tab_eff_Esc_Input = mutate (tab_eff_Input, 
                            Retorno_Escala = ifelse(CRS_Input == VRS_Input, "Constante", 
                                             ifelse(RNC_Input == VRS_Input, "Decrescente", "Crescente")))

############################
##VERIFICAÇÃO DA BASE:###
str(tab_eff_Esc_Input)
View(tab_eff_Esc_Input)
############################

#**********************************************************************************
# Utilizando um teste estatístico para avaliar se temos ineficiência de escala com os Produtos.
ks.test(eff_crs_Output, eff_vrs_Output, alternative = "two.sided", exact = NULL)

# Ho: Ausência de ineficiência de escala 
# (o modelo com a pressuposição de retornos constantes não é o mais adequado);
# Hi: Presença de ineficiência de escala 
# (o modelo com a pressuposição de retornos variáveis não é o mais adequado);

#############
# RESPOSTA:#
##############################################################################################
# Two-sample Kolmogorov-Smirnov test
# data:  eff_crs_Output and eff_vrs_Output
# D = 0.5, p-value = 0.6994
# alternative hypothesis: two-sided
##############################################################################################
#Calculando a eficiência de escala dos Produtos.
eff_Esc_Output = eff_crs_Output/eff_vrs_Output
#**********************************************************************************
# Determinando a natureza dos retornos de escala.
# Retornos crescentes da escala orientada aos Produtos.
eff_Retor_Cres_Output = dea(Outputs, Inputs, RTS = "irs", ORIENTATION = "out")

# Eficiência do retorno crescente dos Produtos.
eff_irs_Output = eff_Retor_Cres_Output$eff
#**********************************************************************************


# Retornos decrescentes de escala orientada aos Produtos.
eff_Retor_Decres_Output = dea(Outputs, Inputs, RTS = "drs", ORIENTATION = "out")

# Eficiência do retorno decrescente dos Produtos.
eff_drs_Output = eff_Retor_Decres_Output$eff
#**********************************************************************************
# Podemos combinar todas as medidas de eficiência em apenas um tabela dos Produtos.
tab_eff_Output = data.frame(DMU         = SMBA$DMU,
                            RND_Output  = eff_irs_Output, 
                            RNC_Output  = eff_drs_Output, 
                            CRS_Output  = eff_crs_Output, 
                            VRS_Output  = eff_vrs_Output, 
                            Eficiência  = eff_Esc_Output)
#**********************************************************************************

################
# OBSERVAÇÃO:#
##############################################################################################
# Podemos criar uma nova variável de nome "Retornos Escala" na base "tab_eff" Usaremos a função "mutate" 
# do pacote "dplyr" para criar uma variável de nome "Retornos Escala", e a função "ifelse" (disponível
# na base do R) para testar as condições.
##############################################################################################
# Concatenando mais de uma função "SE" do Excel, por exemplo:
tab_eff_Esc_Output = mutate (tab_eff_Output, 
                             Retorno_Escala = ifelse(CRS_Output == VRS_Output, "Constante", 
                                              ifelse(RNC_Output == VRS_Output, "Decrescente", "Crescente")))

############################
##VERIFICAÇÃO DA BASE:###
str(tab_eff_Esc_Output)
View(tab_eff_Esc_Output)
############################
#**********************************************************************************
# Por fim, podemos exportar esses dados para uma planilha do Excel:
#writexl::write_xlsx(r.ee, "Estimativas e Retornos.xlsx")

####################################### FIM DO SCRIPT #######################################

########################
# FONTE de Estudo do R:#
########################
#1 Análise Envoltória de Dados: teoria básica
# https://youtu.be/48IjRDP9yd8
#2 Análise Envoltória de Dados: calculando a eficiência técnica no RStudio
# https://youtu.be/Mt8ZdDUcMVc
#3 - Análise Envoltória de Dados no RStudio: Tone (2001)
# https://youtu.be/AqTUK7BILyk?list=PLSCrU1JgFZQORra4F-GrlfyGIbaxALy15
#4 Análise Envoltória de Dados: eficiência e rendimentos de escala
# https://youtu.be/mIG8ZjPLOxU?list=PLSCrU1JgFZQORra4F-GrlfyGIbaxALy15
# Introdução ao R - Módulo 4 (Parte 2)
# http://rstudio-pubs-static.s3.amazonaws.com/331108_5f9778ba77c74b38b5e4e739f82b28b1.html

